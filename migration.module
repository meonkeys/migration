<?php // $Id$

/**
 * @file
 * The Migration module, which helps keep databases in sync.
 *
 * The Migration module is intended to help keep development, staging and
 * production databases in sync. This is done by collecting queries and
 * formatting them as a hook_update_N functon for running on the target
 * site.
 */

/**
 * Implementation of hook_perm().
 */
function migration_perm() {
  return array('administer migration');
}

/**
 * Implementation of hook_menu().
 */
function migration_menu() {
  $items = array();

  $items['admin/settings/migration'] = array(
    'title' => 'Migration',
    'description' => 'Settings for the Migration module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('migration_settings_form'),
    'access arguments' => array('administer migration'),
    'file' => 'migration.admin.inc',
  );

  $items['admin/settings/migration/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['admin/settings/migration/tables'] = array(
    'title' => 'Monitored tables',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('migration_tables_list_form'),
    'access arguments' => array('administer migration'),
    'file' => 'migration.admin.inc',
    'weight' => 1,
  );

  $items['migration/start'] = array(
    'title' => 'Start monitoring',
    'type' => MENU_CALLBACK,
    'page callback' => 'migration_monitor_control',
    'page arguments' => array('start'),
    'access arguments' => array('administer migration'),
    'file' => 'migration.admin.inc',
  );

  $items['migration/stop'] = array(
    'title' => 'Stop monitoring',
    'type' => MENU_CALLBACK,
    'page callback' => 'migration_monitor_control',
    'page arguments' => array('stop'),
    'access arguments' => array('administer migration'),
    'file' => 'migration.admin.inc',
  );

  return $items;
}

function migration_id_safe($string) {
  $search = array(' ', '-');
  return strtolower(str_replace($search, '', $string));
}

/**
 * Implementation of hook_exit().
 *
 * Migration saves all the queries that occurred during this page view.
 */
function migration_exit($destination = NULL) {
  global $queries;

  if (variable_get('dev_query', FALSE) && is_array($queries)) {

    $page_queries = migration_global_queries_processor($queries);
    $valid_queries = migration_filterqueries($page_queries);

    foreach ($valid_queries as $querystruct) {

      $functions[$querystruct['function']] = $querystruct['function'];
      $usernames[$querystruct['username']] = $querystruct['username'];
      //Logic fail.. putting the querstrings into a hash may reorder them as well as eliminate patterns like "INSERT A, DELETE A, INSERT A" and turn it into INSERT A, DELETE A"
      //$querystrings[$querystruct['querystring']] = $querystruct['querystring'];
      $querystrings[] = $querystruct['querystring'];
      $tablename = migration_get_tablename($querystruct['querystring']);
      $tablenames[$tablename] = $tablename;

      // TODO: for debugging - get rid of this later
      // $funcquery[$querystruct['function'] . $querystruct['querystring']] = $querystruct['function'] . $querystruct['querystring'];
    }

    if (variable_get('migration_query_monitor', FALSE)) {

      // Log the sql strings to disk.
      if (is_array($valid_queries)) {

        if (migration_file_append_data(implode("\n", $querystrings), 'queries.sql')) {
          $output .= t('Migration file saved at !file', array('!file' => realpath($migration_get_filename)));
        }
        else {
          $output .= t('Error saving sql file.');
        }
      }
    } 
  
    $output .= migration_format_update_hook($queries);
    drupal_set_message($output, 'status');
  }
}

function migration_get_filename($file) {
  $filename = variable_get('migration_directory_path', file_directory_path() . '/migration') . '/' . $file;
  return $filename;
}

/**
 * Takes the global queries and extracts the query strings, the username, and the function called.
 *
 * @return
 *   An array containing the query data.
 */
function migration_global_queries_processor($queries) {
  foreach ($queries as $query) {
    //regex explain: using % instead of /, the 's' extends the match past single lines.
    preg_match("%(?<function>.*)\n\/\* (?<username>.*) : .*\*\/ (?<querystring>.*)%s", $query[0], $matchedquery);
    //strip initial space
    $matchedquery['querystring'] = preg_replace("/^\s*/s", "", $matchedquery['querystring']);
    //strip linefeeds
    $matchedquery['querystring'] = preg_replace("/\n/s", "", $matchedquery['querystring']);

    $splitqueries[] = $matchedquery;
  }

  //dprint_r($splitqueries);
  return $splitqueries;
}

function migration_file_append_data($input, $filename) {
  if (!file_exists(getcwd() . '/' . variable_get('migration_directory_path', file_directory_path() . '/migration/') . $filename)) {
    $file = file_create_filename($filename, getcwd() . '/' . variable_get('migration_directory_path', file_directory_path() . '/migration'));
  }
  else {
    $file = getcwd() . '/' . variable_get('migration_directory_path', file_directory_path() . '/migration/') . $filename;
  }
  
  $data = file_get_contents($file);
  $data .= $input;
  $return = file_save_data($data, $file, FILE_EXISTS_REPLACE);

  return $return;
}

function migration_query_row($sql) {
  $output .= "  $sql = array($sql);\n";
  return $output;
}

/**
 * This function strips out the individual querystructs that we dont want to
 * keep.
 */
function migration_filterqueries($querystruct) {
  // Filter by querystring
  foreach ($querystruct as $query) {
    if (!migration_is_select_or_show($query['querystring'])) {
      // its *not* a select, so it will change the database.
      // next lets find out if we care if it changes the db.

      // First we check our configured table name list.
      // If its in the "do not record list" we ditch it.
      $tablename = migration_get_tablename($query['querystring']);
      if ((migration_is_table_to_record($tablename)) && (migration_is_valid_function($query['function']))) {
      // Secondly we check the configured function list
      // we will delete by function if we know there are functions we dont care about
      // Finally, if we want to filter by username we can.. later.. later..
        $filteredstruct[] = $query;
      }
    }
  }
  return $filteredstruct;
}

function migration_get_tablename($sqlstring) {
  preg_match("/(INSERT INTO|DELETE FROM|ALTER TABLE|UPDATE|DROP VIEW|CREATE VIEW|DROP TABLE|CREATE TABLE|LOCK TABLES|CREATE DOMAIN|CREATE INDEX|CREATE UNIQUE INDEX|CREATE SEQUENCE|DROP INDEX) (?<tablename>.*?)($| ).*/", $sqlstring, $splitqueries[]);
  return $splitqueries[0]['tablename'];
}

function migration_is_table_to_record($tablename) {
  // TODO: Record them all for now. Get table name list from the database.
  // Do we store the good tables or the bad ones?
  // Record the bad ones.  
  $skiptables = variable_get('migration_database_tables', migration_get_default_tables());

  if (in_array($tablename, $skiptables)) {
    // TODO: Debug
    // print_r ("<H1>irrelevant table $tablename<BR></H1>");
    return FALSE;
  }
  return TRUE;
}

function migration_is_valid_function($function) {

  // TODO: Record them all for now. Get table name list from the database.
  // Hmm.. this is difficult. do we really want to run a slew of regexes against these?
  // perhaps we could sort the regexes by function type..

  $skipfunctions = array(
    'system_theme_data',
    'module_rebuild_cache',
  );

  if (in_array($function, $skipfunctions)) {
    // TODO: Debug
    //print_r ("<H1>irrelevant function $function<BR></H1>");
    return FALSE;
  }
  return TRUE;
}

/**
 * Filters queries that begin with certain keywords.
 *
 * @param $query
 *   The query to test.
 * @return
 *   TRUE if query begines with a certain keyword.
 */
function migration_is_select_or_show($query) {
  $process = FALSE;

  if (stripos($query, 'SELECT') === 0 ||
      stripos($query, 'SHOW') === 0) {
    $process = TRUE;
  }

  return $process;
}

function migration_keepquery($query) {
  // TODO: Either make this configurable or ensure we're excluding the right stuff.

  $process = TRUE;
  $query = trim($query);

  // Starts with...
  if (stripos($query, 'SELECT') === 0 ||
      stripos($query, 'DELETE') === 0 ||
      stripos($query, 'INSERT INTO cache') === 0 ||
      stripos($query, 'INSERT INTO search_') === 0 ||
      stripos($query, 'INSERT INTO watchdog') === 0 ||
      stripos($query, 'INSERT INTO system') === 0 ||
      stripos($query, 'INSERT INTO menu_router') === 0 ||
      stripos($query, 'UPDATE cache') === 0 ||
      stripos($query, 'UPDATE history') === 0 ||
      stripos($query, 'SHOW TABLES') === 0 ||
      stripos($query, 'UPDATE system') === 0 ||
      stripos($query, 'UPDATE sessions') === 0 ||
      stripos($query, 'UPDATE users SET access =') === 0 ||
      stripos($query, 'UPDATE search_total') === 0 ||
      stripos($query, 'UPDATE menu_link') === 0) {
    $process = FALSE;
  }

  // Starts with...
  if (stripos($query, 'UPDATE variable') === 0) {
    // Contains...
    if (stripos($query, 'update_last_check') === TRUE ||
        stripos($query, 'poormanscron_lastrun') === TRUE ||
        stripos($query, 'node_cron_comments_scale') === TRUE ||
        stripos($query, 'node_cron_views_scale') === TRUE ||
        stripos($query, 'node_cron_last') === TRUE ||
        stripos($query, 'migration_query_monitor') === TRUE ||
        stripos($query, 'cron_last') === TRUE) {
      $process = FALSE;
    }
  }

  return $process;
}

function migration_format_update_hook($queries) {
  global $queries;
  $count = migration_get_next_id();

  $output = '<code><pre>';
  $output .= "function mymodule_update_$count() {\n";
  $output .= '  $sql = array();';

  foreach ($queries as $data) {
    $bits = explode("\n", $data[0]);
    $query = preg_replace('|\/\*\s[a-z\s:_]*\*\/\s|', '', $bits[1]);

    $process = migration_keepquery($query);
    if ($process) {
      $output .= "\n";
      $output .= "  /* $bits[0] */\n";
      $output .= '  $sql[] = update_sql($query);';
    }

  }
  $output .= "\n  return \$sql;\n}\n";
  $output .= '</pre></code>';

  return $output;
}

function migration_get_next_id() {
  // TODO: Retrieve next update N from system table.
  return 6000;
}


function migration_init() {
  drupal_add_js(drupal_get_path('module', 'migration') . '/migration.js');
}

function migration_footer($main = 0) {
  $output = '<div style="position: fixed; bottom: 10px; right: 10px; font-size: 0.9em" id="migration-monitor-switch">';

  if (variable_get('migration_query_monitor', FALSE)) {
    $output .= '<a href="#" id="migration-stop-monitor">Stop Query Monitor</a>';
  }
  else {
    $output .= '<a href="#" id="migration-start-monitor">Start Query Monitor</a>';
  }
  $output .= '</div>';

  return $output;
}

function migration_get_default_tables() {
  return array(
    'cache_views',
    'cache',
    'cache_content',
    'cache_menu',
    'cache_admin_menu',
    'cache_update',
    'cache_block',
    'cache_filter',
    'cache_page',
    'cache_calendar_ical',
    'cache_form',
    'history',
    'menu_router',
    'menu_links',
    'watchdogcache',
    'watchdog',
    'sessions',
    'search_dataset',
    'search_index',
    'search_keywords_log',
    'search_total',
    'accesslog',
    'devel_queries',
    'devel_times',
    'menu_router',
    'menu_links',
  );
}
